import {
  VMenuSymbol,
  VOverlay,
  filterVOverlayProps,
  makeVOverlayProps,
  useScopeId
} from "./chunk-W3BDZMHQ.js";
import {
  VDivider
} from "./chunk-DF67U7VH.js";
import {
  VCheckboxBtn
} from "./chunk-OGNLZDGH.js";
import {
  VTextField,
  filterVTextFieldProps,
  makeVTextFieldProps
} from "./chunk-NV7GFRMY.js";
import {
  forwardRefs
} from "./chunk-GFCECH5Z.js";
import {
  useForm
} from "./chunk-IQUDTXCW.js";
import {
  VDialogTransition,
  VExpandTransition,
  VExpandXTransition
} from "./chunk-FJZ5ODT6.js";
import "./chunk-P2JPOOLQ.js";
import {
  makeGroupItemProps,
  makeGroupProps,
  useGroup,
  useGroupItem
} from "./chunk-VNN7UP2A.js";
import {
  VAvatar
} from "./chunk-CPPX4KN5.js";
import "./chunk-JS5S6PQ4.js";
import "./chunk-EISNQBNM.js";
import {
  makeTransitionProps
} from "./chunk-52WAW453.js";
import {
  genOverlays,
  makeBorderProps,
  makeElevationProps,
  makeVariantProps,
  useBorder,
  useElevation,
  useVariant
} from "./chunk-Z4DKFMSA.js";
import {
  VDefaultsProvider,
  makeRouterProps,
  useLink
} from "./chunk-AVACJYHT.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-3QOD7BSS.js";
import {
  Ripple
} from "./chunk-X2R53JYM.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-2TLVFYMV.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-L45IJPPS.js";
import "./chunk-R3VJSODR.js";
import {
  VIcon
} from "./chunk-W43R5JQJ.js";
import {
  makeSizeProps,
  useSize
} from "./chunk-LQW5X6B6.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-AJMN3MKI.js";
import {
  IconValue
} from "./chunk-VVH22WY4.js";
import {
  useLocale,
  useProxiedModel
} from "./chunk-VJ6ZR2LX.js";
import {
  makeThemeProps,
  provideTheme
} from "./chunk-DSRDTFE7.js";
import {
  makeTagProps
} from "./chunk-MM6GSQBR.js";
import {
  EventProp,
  createSimpleFunctional,
  deepEqual,
  defineComponent,
  genericComponent,
  getCurrentInstance,
  getPropertyFromItem,
  getUid,
  omit,
  pick,
  propsFactory,
  provideDefaults,
  useRender,
  wrapInArray
} from "./chunk-MKWIN3KX.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  inject,
  mergeProps,
  onBeforeUnmount,
  provide,
  ref,
  resolveDirective,
  toRef,
  vShow,
  watch,
  withDirectives
} from "./chunk-HEFM7GRK.js";
import "./chunk-RSJERJUL.js";

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "/home/marco/devops/frontend/node_modules/vuetify/lib/components/VSelect/VSelect.css";

// node_modules/vuetify/lib/components/VChip/VChip.mjs
import "/home/marco/devops/frontend/node_modules/vuetify/lib/components/VChip/VChip.css";

// node_modules/vuetify/lib/components/VChipGroup/VChipGroup.mjs
import "/home/marco/devops/frontend/node_modules/vuetify/lib/components/VChipGroup/VChipGroup.css";
var VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
var VChipGroup = defineComponent({
  name: "VChipGroup",
  props: {
    column: Boolean,
    filter: Boolean,
    valueComparator: {
      type: Function,
      default: deepEqual
    },
    ...makeGroupProps({
      selectedClass: "v-chip--selected"
    }),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "tonal"
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props, VChipGroupSymbol);
    provideDefaults({
      VChip: {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        filter: toRef(props, "filter"),
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-chip-group", {
          "v-chip-group--column": props.column
        }, themeClasses.value]
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VChip/VChip.mjs
var VChip = defineComponent({
  name: "VChip",
  directives: {
    Ripple
  },
  props: {
    activeClass: String,
    appendAvatar: String,
    appendIcon: IconValue,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: "$complete"
    },
    label: Boolean,
    link: {
      type: Boolean,
      default: void 0
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: Boolean,
      default: true
    },
    text: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    onClick: EventProp,
    onClickOnce: EventProp,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeGroupItemProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "span"
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "tonal"
    })
  },
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value) => true,
    "group:selected": (val) => true,
    click: (e) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses
    } = useSize(props);
    const {
      themeClasses
    } = provideTheme(props);
    const isActive = useProxiedModel(props, "modelValue");
    const group = useGroupItem(props, VChipGroupSymbol, false);
    const link = useLink(props, attrs);
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value));
    function onCloseClick(e) {
      isActive.value = false;
      emit("click:close", e);
    }
    function onClick(e) {
      var _link$navigate;
      emit("click", e);
      if (!isClickable.value)
        return;
      (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e);
      group == null ? void 0 : group.toggle();
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    return () => {
      var _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasAppend = !!(slots.append || props.appendIcon || props.appendAvatar);
      const hasClose = !!(slots.close || props.closable);
      const hasFilter = !!(slots.filter || props.filter) && group;
      const hasPrepend = !!(slots.prepend || props.prependIcon || props.prependAvatar);
      const hasColor = !group || group.isSelected.value;
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props.disabled,
          "v-chip--label": props.label,
          "v-chip--link": isClickable.value,
          "v-chip--filter": hasFilter,
          "v-chip--pill": props.pill
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value],
        "style": [hasColor ? colorStyles.value : void 0],
        "disabled": props.disabled || void 0,
        "draggable": props.draggable,
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VDefaultsProvider, {
          "key": "filter",
          "defaults": {
            VIcon: {
              icon: props.filterIcon
            }
          }
        }, {
          default: () => [createVNode(VExpandXTransition, null, {
            default: () => [withDirectives(createVNode("div", {
              "class": "v-chip__filter"
            }, [slots.filter ? slots.filter() : createVNode(VIcon, null, null)]), [[vShow, group.isSelected.value]])]
          })]
        }), hasPrepend && createVNode(VDefaultsProvider, {
          "key": "prepend",
          "defaults": {
            VAvatar: {
              image: props.prependAvatar
            },
            VIcon: {
              icon: props.prependIcon
            }
          }
        }, {
          default: () => [slots.prepend ? createVNode("div", {
            "class": "v-chip__prepend"
          }, [slots.prepend()]) : props.prependAvatar ? createVNode(VAvatar, {
            "start": true
          }, null) : props.prependIcon ? createVNode(VIcon, {
            "start": true
          }, null) : void 0]
        }), ((_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected: group == null ? void 0 : group.isSelected.value,
          selectedClass: group == null ? void 0 : group.selectedClass.value,
          select: group == null ? void 0 : group.select,
          toggle: group == null ? void 0 : group.toggle,
          value: group == null ? void 0 : group.value.value,
          disabled: props.disabled
        })) ?? props.text, hasAppend && createVNode(VDefaultsProvider, {
          "key": "append",
          "defaults": {
            VAvatar: {
              image: props.appendAvatar
            },
            VIcon: {
              icon: props.appendIcon
            }
          }
        }, {
          default: () => [slots.append ? createVNode("div", {
            "class": "v-chip__append"
          }, [slots.append()]) : props.appendAvatar ? createVNode(VAvatar, {
            "end": true
          }, null) : props.appendIcon ? createVNode(VIcon, {
            "end": true
          }, null) : void 0]
        }), hasClose && createVNode(VDefaultsProvider, {
          "key": "close",
          "defaults": {
            VIcon: {
              icon: props.closeIcon,
              size: "x-small"
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-chip__close",
            "onClick": onCloseClick
          }, [slots.close ? slots.close() : createVNode(VIcon, null, null)])]
        })]
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
    };
  }
});

// node_modules/vuetify/lib/components/VList/VList.mjs
import "/home/marco/devops/frontend/node_modules/vuetify/lib/components/VList/VList.css";

// node_modules/vuetify/lib/components/VList/list.mjs
var DepthKey = Symbol.for("vuetify:depth");
var ListKey = Symbol.for("vuetify:list");
function createList() {
  const parent = inject(ListKey, {
    hasPrepend: ref(false),
    updateHasPrepend: () => null
  });
  const data = {
    hasPrepend: ref(false),
    updateHasPrepend: (value) => {
      if (value)
        data.hasPrepend.value = value;
    }
  };
  provide(ListKey, data);
  return parent;
}
function useList() {
  return inject(ListKey, null);
}

// node_modules/vuetify/lib/composables/nested/openStrategies.mjs
var singleOpenStrategy = {
  open: (_ref) => {
    let {
      id,
      value,
      opened,
      parents
    } = _ref;
    if (value) {
      const newOpened = /* @__PURE__ */ new Set();
      newOpened.add(id);
      let parent = parents.get(id);
      while (parent != null) {
        newOpened.add(parent);
        parent = parents.get(parent);
      }
      return newOpened;
    } else {
      opened.delete(id);
      return opened;
    }
  },
  select: () => null
};
var multipleOpenStrategy = {
  open: (_ref2) => {
    let {
      id,
      value,
      opened,
      parents
    } = _ref2;
    if (value) {
      let parent = parents.get(id);
      opened.add(id);
      while (parent != null && parent !== id) {
        opened.add(parent);
        parent = parents.get(parent);
      }
      return opened;
    } else {
      opened.delete(id);
    }
    return opened;
  },
  select: () => null
};
var listOpenStrategy = {
  open: multipleOpenStrategy.open,
  select: (_ref3) => {
    let {
      id,
      value,
      opened,
      parents
    } = _ref3;
    if (!value)
      return opened;
    const path = [];
    let parent = parents.get(id);
    while (parent != null) {
      path.push(parent);
      parent = parents.get(parent);
    }
    return new Set(path);
  }
};

// node_modules/vuetify/lib/composables/nested/selectStrategies.mjs
var independentSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref) => {
      let {
        id,
        value,
        selected
      } = _ref;
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
          let [key, value2] = _ref2;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 1 && on[0] === id)
          return selected;
      }
      selected.set(id, value ? "on" : "off");
      return selected;
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents
        });
      }
      return map;
    },
    out: (v) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on")
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
var independentSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref3) => {
      let {
        selected,
        id,
        ...rest
      } = _ref3;
      const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
      return parentStrategy.select({
        ...rest,
        id,
        selected: singleSelected
      });
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      if (v != null && v.length) {
        map = parentStrategy.in(v.slice(0, 1), children, parents);
      }
      return map;
    },
    out: (v, children, parents) => {
      return parentStrategy.out(v, children, parents);
    }
  };
  return strategy;
};
var leafSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref4) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref4;
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
var leafSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSingleSelectStrategy(mandatory);
  const strategy = {
    select: (_ref5) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref5;
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
var classicSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref6) => {
      let {
        id,
        value,
        selected,
        children,
        parents
      } = _ref6;
      const original = new Map(selected);
      const items = [id];
      while (items.length) {
        const item = items.shift();
        selected.set(item, value ? "on" : "off");
        if (children.has(item)) {
          items.push(...children.get(item));
        }
      }
      let parent = parents.get(id);
      while (parent) {
        const childrenIds = children.get(parent);
        const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
        const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
        selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
        parent = parents.get(parent);
      }
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
          let [key, value2] = _ref7;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 0)
          return original;
      }
      return selected;
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents
        });
      }
      return map;
    },
    out: (v, children) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on" && !children.has(key))
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};

// node_modules/vuetify/lib/composables/nested/nested.mjs
var VNestedSymbol = Symbol.for("vuetify:nested");
var emptyNested = {
  id: ref(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: ref(/* @__PURE__ */ new Map()),
    children: ref(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    select: () => null,
    opened: ref(/* @__PURE__ */ new Set()),
    selected: ref(/* @__PURE__ */ new Map()),
    selectedValues: ref([])
  }
};
var makeNestedProps = propsFactory({
  selectStrategy: [String, Function],
  openStrategy: [String, Object],
  opened: Array,
  selected: Array,
  mandatory: Boolean
}, "nested");
var useNested = (props) => {
  let isUnmounted = false;
  const children = ref(/* @__PURE__ */ new Map());
  const parents = ref(/* @__PURE__ */ new Map());
  const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
  const selectStrategy = computed(() => {
    if (typeof props.selectStrategy === "object")
      return props.selectStrategy;
    switch (props.selectStrategy) {
      case "single-leaf":
        return leafSingleSelectStrategy(props.mandatory);
      case "leaf":
        return leafSelectStrategy(props.mandatory);
      case "independent":
        return independentSelectStrategy(props.mandatory);
      case "single-independent":
        return independentSingleSelectStrategy(props.mandatory);
      case "classic":
      default:
        return classicSelectStrategy(props.mandatory);
    }
  });
  const openStrategy = computed(() => {
    if (typeof props.openStrategy === "object")
      return props.openStrategy;
    switch (props.openStrategy) {
      case "list":
        return listOpenStrategy;
      case "single":
        return singleOpenStrategy;
      case "multiple":
      default:
        return multipleOpenStrategy;
    }
  });
  const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents.value), (v) => selectStrategy.value.out(v, children.value, parents.value));
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function getPath(id) {
    const path = [];
    let parent = id;
    while (parent != null) {
      path.unshift(parent);
      parent = parents.value.get(parent);
    }
    return path;
  }
  const vm = getCurrentInstance("nested");
  const nested = {
    id: ref(),
    root: {
      opened,
      selected,
      selectedValues: computed(() => {
        const arr = [];
        for (const [key, value] of selected.value.entries()) {
          if (value === "on")
            arr.push(key);
        }
        return arr;
      }),
      register: (id, parentId, isGroup) => {
        parentId && id !== parentId && parents.value.set(id, parentId);
        isGroup && children.value.set(id, []);
        if (parentId != null) {
          children.value.set(parentId, [...children.value.get(parentId) || [], id]);
        }
      },
      unregister: (id) => {
        if (isUnmounted)
          return;
        children.value.delete(id);
        const parent = parents.value.get(id);
        if (parent) {
          const list = children.value.get(parent) ?? [];
          children.value.set(parent, list.filter((child) => child !== id));
        }
        parents.value.delete(id);
        opened.value.delete(id);
      },
      open: (id, value, event) => {
        vm.emit("click:open", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newOpened = openStrategy.value.open({
          id,
          value,
          opened: new Set(opened.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      openOnSelect: (id, value, event) => {
        const newOpened = openStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          opened: new Set(opened.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      select: (id, value, event) => {
        vm.emit("click:select", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newSelected = selectStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newSelected && (selected.value = newSelected);
        nested.root.openOnSelect(id, value, event);
      },
      children,
      parents
    }
  };
  provide(VNestedSymbol, nested);
  return nested.root;
};
var useNestedItem = (id, isGroup) => {
  const parent = inject(VNestedSymbol, emptyNested);
  const computedId = computed(() => id.value ?? Symbol(getUid()));
  const item = {
    ...parent,
    id: computedId,
    open: (open, e) => parent.root.open(computedId.value, open, e),
    openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),
    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
    parent: computed(() => parent.root.parents.value.get(computedId.value)),
    select: (selected, e) => parent.root.select(computedId.value, selected, e),
    isSelected: computed(() => parent.root.selected.value.get(computedId.value) === "on"),
    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
    isGroupActivator: parent.isGroupActivator
  };
  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
  onBeforeUnmount(() => {
    !parent.isGroupActivator && parent.root.unregister(computedId.value);
  });
  isGroup && provide(VNestedSymbol, item);
  return item;
};
var useNestedGroupActivator = () => {
  const parent = inject(VNestedSymbol, emptyNested);
  provide(VNestedSymbol, {
    ...parent,
    isGroupActivator: true
  });
};

// node_modules/vuetify/lib/components/VList/VListGroup.mjs
var VListGroupActivator = defineComponent({
  name: "VListGroupActivator",
  setup(_, _ref) {
    let {
      slots
    } = _ref;
    useNestedGroupActivator();
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
    };
  }
});
var makeVListGroupProps = propsFactory({
  activeColor: String,
  color: String,
  collapseIcon: {
    type: IconValue,
    default: "$collapse"
  },
  expandIcon: {
    type: IconValue,
    default: "$expand"
  },
  prependIcon: IconValue,
  appendIcon: IconValue,
  fluid: Boolean,
  subgroup: Boolean,
  value: null,
  ...makeTagProps()
}, "v-list-group");
var VListGroup = genericComponent()({
  name: "VListGroup",
  props: {
    title: String,
    ...makeVListGroupProps()
  },
  setup(props, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      isOpen,
      open,
      id: _id
    } = useNestedItem(toRef(props, "value"), true);
    const id = computed(() => `v-list-group--id-${String(_id.value)}`);
    const list = useList();
    function onClick(e) {
      open(!isOpen.value, e);
    }
    const activatorProps = computed(() => ({
      onClick,
      class: "v-list-group__header",
      id: id.value
    }));
    const toggleIcon = computed(() => isOpen.value ? props.collapseIcon : props.expandIcon);
    useRender(() => {
      var _slots$default2;
      return createVNode(props.tag, {
        "class": ["v-list-group", {
          "v-list-group--prepend": list == null ? void 0 : list.hasPrepend.value,
          "v-list-group--fluid": props.fluid,
          "v-list-group--subgroup": props.subgroup,
          "v-list-group--open": isOpen.value
        }]
      }, {
        default: () => [slots.activator && createVNode(VDefaultsProvider, {
          "defaults": {
            VListItem: {
              active: isOpen.value,
              activeColor: props.activeColor,
              color: props.color,
              prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
              appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
              title: props.title,
              value: props.value
            }
          }
        }, {
          default: () => [createVNode(VListGroupActivator, null, {
            default: () => [slots.activator({
              props: activatorProps.value,
              isOpen
            })]
          })]
        }), createVNode(VExpandTransition, null, {
          default: () => [withDirectives(createVNode("div", {
            "class": "v-list-group__items",
            "role": "group",
            "aria-labelledby": id.value
          }, [(_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)]), [[vShow, isOpen.value]])]
        })]
      });
    });
    return {};
  }
});
function filterListGroupProps(props) {
  return pick(props, Object.keys(VListGroup.props));
}

// node_modules/vuetify/lib/components/VList/VListItem.mjs
import "/home/marco/devops/frontend/node_modules/vuetify/lib/components/VList/VListItem.css";

// node_modules/vuetify/lib/components/VList/VListItemSubtitle.mjs
var VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");

// node_modules/vuetify/lib/components/VList/VListItemTitle.mjs
var VListItemTitle = createSimpleFunctional("v-list-item-title");

// node_modules/vuetify/lib/components/VList/VListItem.mjs
var VListItem = genericComponent()({
  name: "VListItem",
  directives: {
    Ripple
  },
  props: {
    active: {
      type: Boolean,
      default: void 0
    },
    activeClass: String,
    activeColor: String,
    appendAvatar: String,
    appendIcon: IconValue,
    disabled: Boolean,
    lines: String,
    link: {
      type: Boolean,
      default: void 0
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: Boolean,
      default: true
    },
    subtitle: [String, Number, Boolean],
    title: [String, Number, Boolean],
    value: null,
    onClick: EventProp,
    onClickOnce: EventProp,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "text"
    })
  },
  emits: {
    click: (e) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const link = useLink(props, attrs);
    const id = computed(() => props.value ?? link.href.value);
    const {
      select,
      isSelected,
      isIndeterminate,
      isGroupActivator,
      root,
      parent,
      openOnSelect
    } = useNestedItem(id, false);
    const list = useList();
    const isActive = computed(() => {
      var _link$isActive;
      return props.active !== false && (props.active || ((_link$isActive = link.isActive) == null ? void 0 : _link$isActive.value) || isSelected.value);
    });
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value || props.value != null && !!list));
    const roundedProps = computed(() => props.rounded || props.nav);
    const variantProps = computed(() => ({
      color: isActive.value ? props.activeColor ?? props.color : props.color,
      variant: props.variant
    }));
    watch(() => {
      var _link$isActive2;
      return (_link$isActive2 = link.isActive) == null ? void 0 : _link$isActive2.value;
    }, (val) => {
      if (val && parent.value != null) {
        root.open(parent.value, true);
      }
      if (val) {
        openOnSelect(val);
      }
    }, {
      immediate: true
    });
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(roundedProps);
    const lineClasses = computed(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
    const slotProps = computed(() => ({
      isActive: isActive.value,
      select,
      isSelected: isSelected.value,
      isIndeterminate: isIndeterminate.value
    }));
    function onClick(e) {
      var _link$navigate;
      emit("click", e);
      if (isGroupActivator || !isClickable.value)
        return;
      (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e);
      props.value != null && select(!isSelected.value, e);
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    useRender(() => {
      var _slots$prepend, _slots$title, _slots$subtitle, _slots$default, _slots$append;
      const Tag = isLink.value ? "a" : props.tag;
      const hasColor = !list || isSelected.value || isActive.value;
      const hasTitle = slots.title || props.title;
      const hasSubtitle = slots.subtitle || props.subtitle;
      const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
      const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
      list == null ? void 0 : list.updateHasPrepend(hasPrepend);
      return withDirectives(createVNode(Tag, {
        "class": ["v-list-item", {
          "v-list-item--active": isActive.value,
          "v-list-item--disabled": props.disabled,
          "v-list-item--link": isClickable.value,
          "v-list-item--nav": props.nav,
          "v-list-item--prepend": !hasPrepend && (list == null ? void 0 : list.hasPrepend.value),
          [`${props.activeClass}`]: props.activeClass && isActive.value
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value],
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode(VDefaultsProvider, {
          "key": "prepend",
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.prependAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.prependIcon
            },
            VListItemAction: {
              start: true
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-list-item__prepend"
          }, [props.prependAvatar && createVNode(VAvatar, {
            "key": "prepend-avatar"
          }, null), props.prependIcon && createVNode(VIcon, {
            "key": "prepend-icon"
          }, null), (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, slotProps.value)])]
        }), createVNode("div", {
          "class": "v-list-item__content",
          "data-no-activator": ""
        }, [hasTitle && createVNode(VListItemTitle, {
          "key": "title"
        }, {
          default: () => [((_slots$title = slots.title) == null ? void 0 : _slots$title.call(slots, {
            title: props.title
          })) ?? props.title]
        }), hasSubtitle && createVNode(VListItemSubtitle, {
          "key": "subtitle"
        }, {
          default: () => [((_slots$subtitle = slots.subtitle) == null ? void 0 : _slots$subtitle.call(slots, {
            subtitle: props.subtitle
          })) ?? props.subtitle]
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)]), hasAppend && createVNode(VDefaultsProvider, {
          "key": "append",
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.appendAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.appendIcon
            },
            VListItemAction: {
              end: true
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-list-item__append"
          }, [(_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots, slotProps.value), props.appendIcon && createVNode(VIcon, {
            "key": "append-icon"
          }, null), props.appendAvatar && createVNode(VAvatar, {
            "key": "append-avatar"
          }, null)])]
        })]
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VList/VListSubheader.mjs
var VListSubheader = defineComponent({
  name: "VListSubheader",
  props: {
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String,
    ...makeTagProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    useRender(() => {
      var _slots$default;
      const hasText = !!(slots.default || props.title);
      return createVNode(props.tag, {
        "class": ["v-list-subheader", {
          "v-list-subheader--inset": props.inset,
          "v-list-subheader--sticky": props.sticky
        }, textColorClasses.value],
        "style": {
          textColorStyles
        }
      }, {
        default: () => [hasText && createVNode("div", {
          "class": "v-list-subheader__text"
        }, [((_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)) ?? props.title])]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VList/VListChildren.mjs
var VListChildren = genericComponent()({
  name: "VListChildren",
  props: {
    items: Array
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    createList();
    return () => {
      var _slots$default, _props$items;
      return ((_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)) ?? ((_props$items = props.items) == null ? void 0 : _props$items.map((_ref2) => {
        let {
          children,
          props: itemProps,
          type,
          raw: item
        } = _ref2;
        if (type === "divider") {
          var _slots$divider;
          return ((_slots$divider = slots.divider) == null ? void 0 : _slots$divider.call(slots, {
            props: itemProps
          })) ?? createVNode(VDivider, itemProps, null);
        }
        if (type === "subheader") {
          var _slots$subheader;
          return ((_slots$subheader = slots.subheader) == null ? void 0 : _slots$subheader.call(slots, {
            props: itemProps
          })) ?? createVNode(VListSubheader, itemProps, {
            default: slots.subheader
          });
        }
        const slotsWithItem = {
          subtitle: slots.subtitle ? (slotProps) => {
            var _slots$subtitle;
            return (_slots$subtitle = slots.subtitle) == null ? void 0 : _slots$subtitle.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          prepend: slots.prepend ? (slotProps) => {
            var _slots$prepend;
            return (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          append: slots.append ? (slotProps) => {
            var _slots$append;
            return (_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          default: slots.default ? (slotProps) => {
            var _slots$default2;
            return (_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          title: slots.title ? (slotProps) => {
            var _slots$title;
            return (_slots$title = slots.title) == null ? void 0 : _slots$title.call(slots, {
              ...slotProps,
              item
            });
          } : void 0
        };
        const [listGroupProps, _1] = filterListGroupProps(itemProps);
        return children ? createVNode(VListGroup, mergeProps({
          "value": itemProps == null ? void 0 : itemProps.value
        }, listGroupProps), {
          activator: (_ref3) => {
            let {
              props: activatorProps
            } = _ref3;
            return slots.header ? slots.header({
              ...itemProps,
              ...activatorProps
            }) : createVNode(VListItem, mergeProps(itemProps, activatorProps), slotsWithItem);
          },
          default: () => createVNode(VListChildren, {
            "items": children
          }, slots)
        }) : slots.item ? slots.item(itemProps) : createVNode(VListItem, itemProps, slotsWithItem);
      }));
    };
  }
});

// node_modules/vuetify/lib/composables/items.mjs
var makeItemsProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean
}, "item");
function transformItem(props, item) {
  const title = getPropertyFromItem(item, props.itemTitle, item);
  const value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue, title);
  const children = getPropertyFromItem(item, props.itemChildren);
  const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? pick(item, ["children"])[1] : item : void 0 : getPropertyFromItem(item, props.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    title: String(_props.title ?? ""),
    value: _props.value,
    props: _props,
    children: Array.isArray(children) ? transformItems(props, children) : void 0,
    raw: item
  };
}
function transformItems(props, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem(props, item));
  }
  return array;
}
function useItems(props) {
  const items = computed(() => transformItems(props, props.items));
  function transformIn(value) {
    return value.map((item) => transformItem(props, item));
  }
  function transformOut(value) {
    return value.map((_ref) => {
      let {
        props: props2
      } = _ref;
      return props2.value;
    });
  }
  return {
    items,
    transformIn,
    transformOut
  };
}

// node_modules/vuetify/lib/components/VList/VList.mjs
function transformItem2(props, item) {
  const type = getPropertyFromItem(item, props.itemType, "item");
  const title = typeof item === "string" ? item : getPropertyFromItem(item, props.itemTitle);
  const value = getPropertyFromItem(item, props.itemValue, void 0);
  const children = getPropertyFromItem(item, props.itemChildren);
  const itemProps = props.itemProps === true ? pick(item, ["children"])[1] : getPropertyFromItem(item, props.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    type,
    title: _props.title,
    value: _props.value,
    props: _props,
    children: type === "item" && children ? transformItems2(props, children) : void 0,
    raw: item
  };
}
function transformItems2(props, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem2(props, item));
  }
  return array;
}
function useListItems(props) {
  const items = computed(() => transformItems2(props, props.items));
  return {
    items
  };
}
var VList = genericComponent()({
  name: "VList",
  props: {
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    lines: {
      type: [Boolean, String],
      default: "one"
    },
    nav: Boolean,
    ...makeNestedProps({
      selectStrategy: "single-leaf",
      openStrategy: "list"
    }),
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    itemType: {
      type: String,
      default: "type"
    },
    ...makeItemsProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "text"
    })
  },
  emits: {
    "update:selected": (val) => true,
    "update:opened": (val) => true,
    "click:open": (value) => true,
    "click:select": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      items
    } = useListItems(props);
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      borderClasses
    } = useBorder(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      open,
      select
    } = useNested(props);
    const lineClasses = computed(() => props.lines ? `v-list--${props.lines}-line` : void 0);
    const activeColor = toRef(props, "activeColor");
    const color = toRef(props, "color");
    createList();
    provideDefaults({
      VListGroup: {
        activeColor,
        color
      },
      VListItem: {
        activeClass: toRef(props, "activeClass"),
        activeColor,
        color,
        density: toRef(props, "density"),
        disabled: toRef(props, "disabled"),
        lines: toRef(props, "lines"),
        nav: toRef(props, "nav"),
        variant: toRef(props, "variant")
      }
    });
    const isFocused = ref(false);
    const contentRef = ref();
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      var _contentRef$value;
      if (!isFocused.value && !(e.relatedTarget && (_contentRef$value = contentRef.value) != null && _contentRef$value.contains(e.relatedTarget)))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (e.key === "ArrowDown") {
        focus("next");
      } else if (e.key === "ArrowUp") {
        focus("prev");
      } else if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      } else {
        return;
      }
      e.preventDefault();
    }
    function focus(location) {
      if (!contentRef.value)
        return;
      const focusable = [...contentRef.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter((el) => !el.hasAttribute("disabled"));
      const idx = focusable.indexOf(document.activeElement);
      if (!location) {
        if (!contentRef.value.contains(document.activeElement)) {
          var _focusable$;
          (_focusable$ = focusable[0]) == null ? void 0 : _focusable$.focus();
        }
      } else if (location === "first") {
        var _focusable$2;
        (_focusable$2 = focusable[0]) == null ? void 0 : _focusable$2.focus();
      } else if (location === "last") {
        var _focusable$at;
        (_focusable$at = focusable.at(-1)) == null ? void 0 : _focusable$at.focus();
      } else {
        let el;
        let idxx = idx;
        const inc = location === "next" ? 1 : -1;
        do {
          idxx += inc;
          el = focusable[idxx];
        } while ((!el || el.offsetParent == null) && idxx < focusable.length && idxx >= 0);
        if (el)
          el.focus();
        else
          focus(location === "next" ? "first" : "last");
      }
    }
    useRender(() => {
      return createVNode(props.tag, {
        "ref": contentRef,
        "class": ["v-list", {
          "v-list--disabled": props.disabled,
          "v-list--nav": props.nav
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, dimensionStyles.value],
        "role": "listbox",
        "aria-activedescendant": void 0,
        "onFocusin": onFocusin,
        "onFocusout": onFocusout,
        "onFocus": onFocus,
        "onKeydown": onKeydown
      }, {
        default: () => [createVNode(VListChildren, {
          "items": items.value
        }, slots)]
      });
    });
    return {
      open,
      select,
      focus
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListImg.mjs
var VListImg = createSimpleFunctional("v-list-img");

// node_modules/vuetify/lib/components/VList/VListItemAction.mjs
var VListItemAction = defineComponent({
  name: "VListItemAction",
  props: {
    start: Boolean,
    end: Boolean,
    ...makeTagProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(props.tag, {
      "class": ["v-list-item-action", {
        "v-list-item-action--start": props.start,
        "v-list-item-action--end": props.end
      }]
    }, slots));
    return {};
  }
});

// node_modules/vuetify/lib/components/VList/VListItemMedia.mjs
var VListItemMedia = defineComponent({
  name: "VListItemMedia",
  props: {
    start: Boolean,
    end: Boolean,
    ...makeTagProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      return createVNode(props.tag, {
        "class": ["v-list-item-media", {
          "v-list-item-media--start": props.start,
          "v-list-item-media--end": props.end
        }]
      }, slots);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VMenu/VMenu.mjs
import "/home/marco/devops/frontend/node_modules/vuetify/lib/components/VMenu/VMenu.css";
var VMenu = genericComponent()({
  name: "VMenu",
  props: {
    // TODO
    // disableKeys: Boolean,
    id: String,
    ...omit(makeVOverlayProps({
      closeDelay: 250,
      closeOnContentClick: true,
      locationStrategy: "connected",
      openDelay: 300,
      scrim: false,
      scrollStrategy: "reposition",
      transition: {
        component: VDialogTransition
      }
    }), ["absolute"])
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid = getUid();
    const id = computed(() => props.id || `v-menu-${uid}`);
    const overlay = ref();
    const parent = inject(VMenuSymbol, null);
    let openChildren = 0;
    provide(VMenuSymbol, {
      register() {
        ++openChildren;
      },
      unregister() {
        --openChildren;
      },
      closeParents() {
        setTimeout(() => {
          if (!openChildren) {
            isActive.value = false;
            parent == null ? void 0 : parent.closeParents();
          }
        }, 40);
      }
    });
    watch(isActive, (val) => {
      val ? parent == null ? void 0 : parent.register() : parent == null ? void 0 : parent.unregister();
    });
    function onClickOutside() {
      parent == null ? void 0 : parent.closeParents();
    }
    useRender(() => {
      const [overlayProps] = filterVOverlayProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-menu"]
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "absolute": true,
        "activatorProps": mergeProps({
          "aria-haspopup": "menu",
          "aria-expanded": String(isActive.value),
          "aria-owns": id.value
        }, props.activatorProps),
        "onClick:outside": onClickOutside
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          var _slots$default;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": true
          }, {
            default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, ...args)]
          });
        }
      });
    });
    return forwardRefs({
      id
    }, overlay);
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeItemsProps({
    itemChildren: false
  })
}, "v-select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: {
    ...makeSelectProps(),
    ...omit(makeVTextFieldProps({
      modelValue: null
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...makeTransitionProps({
      transition: {
        component: VDialogTransition
      }
    })
  },
  emits: {
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const menu = useProxiedModel(props, "menu");
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => props.valueComparator(item.value, v.value)) || v;
      });
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    const displayItems = computed(() => {
      if (props.hideSelected) {
        return items.value.filter((item) => !selections.value.some((s) => s === item));
      }
      return items.value;
    });
    const listRef = ref();
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length || props.readonly || form != null && form.isReadonly.value)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (props.readonly || form != null && form.isReadonly.value)
        return;
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        e.preventDefault();
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "ArrowDown") {
        var _listRef$value;
        (_listRef$value = listRef.value) == null ? void 0 : _listRef$value.focus("next");
      } else if (e.key === "ArrowUp") {
        var _listRef$value2;
        e.preventDefault();
        (_listRef$value2 = listRef.value) == null ? void 0 : _listRef$value2.focus("prev");
      } else if (e.key === "Home") {
        var _listRef$value3;
        e.preventDefault();
        (_listRef$value3 = listRef.value) == null ? void 0 : _listRef$value3.focus("first");
      } else if (e.key === "End") {
        var _listRef$value4;
        e.preventDefault();
        (_listRef$value4 = listRef.value) == null ? void 0 : _listRef$value4.focus("last");
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selected.value.findIndex((selection) => props.valueComparator(selection, item.value));
        if (index === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      var _listRef$value5;
      if (!((_listRef$value5 = listRef.value) != null && _listRef$value5.$el.contains(e.relatedTarget))) {
        menu.value = false;
      }
    }
    function onFocusout(e) {
      if (e.relatedTarget == null) {
        var _vTextFieldRef$value;
        (_vTextFieldRef$value = vTextFieldRef.value) == null ? void 0 : _vTextFieldRef$value.focus();
      }
    }
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots.prepend || slots.append || slots["no-data"]);
      const [textFieldProps] = filterVTextFieldProps(props);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "validationValue": model.externalValue,
        "dirty": model.value.length > 0,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:control": onClickControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => {
          var _slots$noData, _slots$prependItem, _slots$appendItem;
          return createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-select__content",
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition
          }, props.menuProps), {
            default: () => [hasList && createVNode(VList, {
              "ref": listRef,
              "selected": selected.value,
              "selectStrategy": props.multiple ? "independent" : "single-independent",
              "onMousedown": (e) => e.preventDefault(),
              "onFocusout": onFocusout
            }, {
              default: () => [!displayItems.value.length && !props.hideNoData && (((_slots$noData = slots["no-data"]) == null ? void 0 : _slots$noData.call(slots)) ?? createVNode(VListItem, {
                "title": t(props.noDataText)
              }, null)), (_slots$prependItem = slots["prepend-item"]) == null ? void 0 : _slots$prependItem.call(slots), displayItems.value.map((item, index) => {
                if (slots.item) {
                  var _slots$item;
                  return (_slots$item = slots.item) == null ? void 0 : _slots$item.call(slots, {
                    item,
                    index,
                    props: mergeProps(item.props, {
                      onClick: () => select(item)
                    })
                  });
                }
                return createVNode(VListItem, mergeProps({
                  "key": index
                }, item.props, {
                  "onClick": () => select(item)
                }), {
                  prepend: (_ref2) => {
                    let {
                      isSelected
                    } = _ref2;
                    return props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                      "modelValue": isSelected,
                      "ripple": false
                    }, null) : void 0;
                  }
                });
              }), (_slots$appendItem = slots["append-item"]) == null ? void 0 : _slots$appendItem.call(slots)]
            })]
          }), selections.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            return createVNode("div", {
              "key": item.value,
              "class": "v-select__selection"
            }, [hasChips ? createVNode(VDefaultsProvider, {
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slots.chip ? slots.chip({
                item,
                index,
                props: slotProps
              }) : createVNode(VChip, slotProps, null)]
            }) : slots.selection ? slots.selection({
              item,
              index
            }) : createVNode("span", {
              "class": "v-select__selection-text"
            }, [item.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
              "class": "v-select__selection-comma"
            }, [createTextVNode(",")])])]);
          })]);
        }
      });
    });
    return forwardRefs({
      menu,
      select
    }, vTextFieldRef);
  }
});
export {
  VSelect
};
//# sourceMappingURL=vuetify_lib_components_VSelect_index__mjs.js.map
